> 一种关系型数据库

### 执行流程
1. 连接器，判读是否有权限
2. 查询缓存
3. 分析器：词法分析 语法分析
4. 优化器：分析并使用最优的执行方案
5. 执行器：调用存储引擎

查询语句的执行流程如下：权限校验（如果命中缓存）---》查询缓存---》分析器---》优化器---》权限校验---》执行器---》引擎

更新语句执行流程如下：分析器----》权限校验----》执行器---》引擎---redo log(prepare 状态---》binlog---》redo log(commit状态)

### 数据库范式
1. 第一范式，列不可分割
2. 第二范式，非主属性完全函数依赖于主属性，解决部分函数依赖
3. 第三范式，非主键列直接函数依赖主键，解决传递函数依赖


### 数据库事务
> 事务会把数据库从一种一致状态转换为另一种一致状态 

> 逻辑上的一组操作，要么都执行，要么都不执行
- A  原子性 一个事务中的操作要么全部完成，要么全部失败
- C 一致性 事务前后保持一致
- I 持久性 对数据的改变是永久的
- D 隔离性 并发事务之间不相互影响，互相隔离

> 事务的隔离性使用锁来实现，原子性，一致性，持久性通过数据库的redolog（重做日志，原子性和持久性）和undolog（一致性）来完成。


逻辑日志：可理解为sql语句
物理日志：数据页的变更

redo和undo都可以视为一种恢复操作，redo恢复提交事务修改的页操作，undo回滚行记录到某个特定版

redolog通常是物理日志，记录的是页的物理修改操作，记录事务执行后的状态，用于恢复未写入data file的已成功的事务更新的数据。
undolog是逻辑日志，根据每行记录进行记录，用于记录事务开始前的状态，用于事务失败时的回滚操作。


######  redolog
innodb实现，保证一致性，物理日志，记录事务对数据页的修改，降低对数据页刷盘的要求，恢复时速度会比（binlog）快很多，循环写，会覆盖
防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务时，根据redo log进行重做，从而达到事务的持久性。

重做日志缓冲 redo log buffer
重做日志文件 redo log file

redolog基本都是顺序写，在数据库运行期间不需要对redolog文件进行读取操作。

innodb存储引擎在启动时会尝试进行恢复操作。

每执行一条DML语句，先将记录写入redo log buffer，后续某个时间点再一次性将多个操作记录写到redo log file。
用户空间下的缓冲区数据一般情况是无法直接写入此磁盘的，中间必须经过操作系统内核空间缓冲区（OS buffer），redo log buffer 写入redo log file前需要先写入OS buffer。

刷盘时机
0：延迟写，延迟写入osbuffer并刷盘
1：实时刷，实时写入osbuffer并刷盘
2：延迟刷，实时写入osbuffer延迟刷盘


###### undolog
随机读写，与执行sql相反的工作。mvcc也是通过undolog实现的，当用户读取一行记录，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。undolog会产生redolog，因为undolog也需要持久性保护。


###### binlog
> 逻辑日志，记录数据库执行的写入性操作信息，以二进制形式保存  
> 以追加的方式写入，当文件达到最大值后，生成新的文件进行操作
- 主从复制：在主库开启binlog，然后将binlog发送到各个从库，从库重放binlog从而达到主从一致
- 数据恢复：通过使用mysqlbinglog工具来恢复数据

刷盘时机
事务提交时才会记录binlog，此时记录还在内存中，可设置不同的刷盘策略控制刷盘时机
0：不强制要求，系统自行刷盘
1：每提交一个事务进行刷盘一次
N：每N个事务刷盘一次

事务执行完成的标志是写完redolog和undolog。如果在写redo log的时候断电，事务则没有执行完毕，则会根据undolog回滚到事务之前


### 数据库隔离级别

- 读未提交 脏读 不可重复读 幻读
- 读已提交 不可重复读 幻读
- 可重复读 幻读 默认事务隔离级别
- 序列化


- 脏读 读未提交
- 不可重复读 一个事务内的多次读操作中间存在其他事务对数据进行了吸怪，导致多次读的数据不一致
- 幻读 类似不可重复读，幻读是对读取的数据数量的改变，一般是数据范围改变，不可重复读是指行内数据被修改

查看数据库隔离级别
select @@ts_isolation


### 数据库索引
##### 定义
> 帮助MySQL高效获取数据的数据结构。满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构，就是索引。


##### 索引类型
- 唯一索引 唯一值，允许为null
- 主键索引 唯一索引的特殊案例，唯一但不允许为null,且最多只能有一个主键索引，主键索引是聚集索引，其它为非聚集索引
- 联合索引 多个列合并组成的索引
- 全文索引 MyISAM的特殊索引类型，用于全文检索


##### 索引存储方式
- 聚集索引（聚簇索引）
>数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，即聚集索引确定表中数据的物理顺序，一个表中只能拥有一个聚集索引。数据文件同时是索引文件。主要用于InnoDb存储引擎
- 非聚集索引（非聚簇索引）
> 索引文件存放的只是数据的地址
- 优劣对比
> 聚集索引使得按照主键索引查询变得十分高效，但使用辅助索引时需要查询两遍，第一遍在辅助索引文件上查询，查出主键后再根据主键索引文件进行一次查询得到完整的数据。当使用辅助索引只查询主键的值时即覆盖索引，则不需要第二次查询。



### 索引的数据结构
##### B+树
> 多叉排序树，每个非叶子节点有多个子节点，节点中的数据按顺序排列，父节点中的数据子节点中也一定存在，且是子节点中最大（或最小）的值。


- 与B树（=B-树）的区别
1. B+树的非叶子节点仅具有索引功能，不包含数据
2. B+树的所有叶子节点链接成一个有序链表
3. B+树父节点的数据在子节点中也一定存在


- 优点
1.  一个节点中能够存放更多的数据，减少IO次数。（一个磁盘块中可以存放更多的数据，降低树的高度）
2.  所有叶子节点组成一个单向链表，便于范围查询
3.  所有查询需要的数据都存放在叶子节点，查询性能更稳定

- 缺点
1. 创建和维护需要时间
2. 占用额外的物理空间

- 结构图
![image](http://img.mp.sohu.com/upload/20170713/358025867be14bb99bf8806b98e774d9_th.png)


#### 索引使用
使用explain对mysql进行执行分析判断sql执行效率，进一步进行优化。
1. id 执行顺序
2. select_type 查询类型，区别普通查询、联合查询、子查询等复杂查询
> 1. simple 简单的子查询，不包含子查询或者union
> 2. primary 若包含任何复杂的子查询，则最外层的查询为primary
> 3. subquery 子查询
> 4. DERIVED 在from 列表中的子查询会标记成derived (衍生的)
> 5. union  第二个select 出现在union后则标记为union
> 6. union result 从union表获取结果的查询

3. table 表
4. partitions 分区
5. type 
> 1. NULL 能够在优化阶段分解查询语句，查询阶段不需要再访问数据或索引
> 2. system 只有一行数据，const类型的特例
> 3. const 常数，最多只有一个匹配行
> 4. eq_ref 唯一性索引扫描，对于每个索引键，表中只有一条记录匹配，常见于主键或唯一索引
> 5. ref 非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是索引访问
> 6. ref_or_null 类似ref，但是可以搜索值为NULL的行
> 7. index_merge 使用了索引合并的优化方法
> 8. range 只检索给定范围的行，常见于< > in between等
> 9. index 遍历索引树
> 10. ALL 全表扫描
6. possible_keys 可能使用的索引，但不一定被实际使用
7. key 实际使用的索引
8. key_len 索引的长度
9. ref 显示索引的哪一列被使用
10. rows 大致读取的行数
11. filtered 查询的行数占全表的百分比
12. extra 不适合在其他列中显示但十分重要的额外信息
> 1. using filesort 文件排序
> 2. using temporary 使用临时表，常见于orderby、groupby
> 3. using index select 操作使用了覆盖索引，避免访问数据行
> 4. using where 使用了where 条件
> 5. using join buffer 使用连接缓存
> 6. impossible where where 总是false
> 7. distinct 一旦查询到相匹配的行，就不再查询
> 8. select table optimized table select操作已经不能在优化了

#### 建立索引
1. 最左前缀匹配原则
> 多列索引从左往右匹配，遇到范围查询则停止匹配，例如> < between like
2. =和in
> 使用= 和in 可以乱序，优化器会自动对查询的列进行优化排序
3. 索引列不能参与计算，保持查询列干净
> 索引列参与了计算时，会导致使用索引时对每一个数据都进行计算，开销很大
4. 使用区分度高的列建立索引
> 使用区分度低的列建立的索引进行查询，对于查询效率并没有很大的提升
5. 尽量扩展索引而不是新建索引
6. 常用的查询、分组、排序的列


#### 锁


##### 表锁
> 锁定整个表，粒度小，开销小，速度快，低并发，实现简单，不会出现死锁。
##### 行锁
> 只锁定操作数据行，粒度大，开销大，高并发，实现复杂，会出现死锁。
##### 页锁
> 锁定相邻的一组数据。

##### 共享锁 
> shared lock  s锁 读锁 允许多个事务同时对数据加读锁，但不能在读锁的数据对象上加写锁，读锁只允许事务进行读操作
##### 排他锁
> Exclusive lock x锁 写锁 只允许一个事务对数据进行添加写锁，添加了写锁的事务可读可写，不允许其他事务加锁


>innodb的行级锁是根据索引进行锁定的，如果未命中任务索引，则使用表级锁
innodb锁时锁定索引，即可能数据行不同但索引相同的情况也会发生锁冲突


#### MySQL优化

##### 超大分页
    select * from table where fid in (select id from table limit offset,count);
    使用覆盖索引提高速度
    










