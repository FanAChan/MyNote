## 内存区域
1. 虚拟机栈
> 方法调用栈，一个方法调用则一个栈帧入栈，方法结束或异常退出则出栈。栈帧中包含了局部变量表，操作数栈，动态链接，出口信息等。
2. 本地方法栈
> 类似于虚拟机栈，但本地方法栈中的方法调用只针对本地（native）方法。
3. 程序计数器
> 行号计数器，记录当前线程执行位置，负责控制代码的流程同时为切换线程做准备。
4. 堆
> 保存对象实例，GC的主要区域。
5. 方法区
> 加载类的信息，存储类定义数据。运行池常量池也是方法区的一部分。
> 包括加载的类信息，常量，静态变量等

## 内存模型 JMM Java Memory Model
> 线程不直接操作内存中的变量，而是每个线程会有一个工作内存，工作内存中保存主内存的变量的副本，线程直接操作工作内存中的变量，然后再同步回主存，主存线程共享，工作内存线程私有。

## GC

#### GC算法
1. 标记清除
>  先标记，然后对对象进行清除
> 缺点：内存碎片
2. 复制
> 只使用一半的堆区，gc时直接将存活对象复制到另外一半的堆区，清除另外一半。
> 缺点：只使用了一般的堆
3. 标记整理（标记压缩）
> 标记后对对象进行整理，往内存的一端移动
> 需要移动对象，成本较高
4. 分代收集算法
> 综合以上几种算法的优缺点，对不同区域内的不同对象使用不同的算法。
> 新生代，
> 年老代
> 持久代

#### 对象存活判断
1. 引用计数法
> 在对象上维护被引用的数量，为0的即为不被引用的对象，可直接清除
> 问题：循环引用问题
2. 可达性分析
> 从GC Roots出发，可达的对象即存活
> GC Roots
> 1. 虚拟机栈中引用的对象
> 2. 本地虚拟机栈中引用的对象
> 3. 方法区中的静态属性引用的对象
> 4. 方法区中的常量引用的对象


#### 创建对象的过程
> 对象引用在虚拟机栈的本地变量表中
>
> 1，大多数情况下直接在堆内存的新生代Eden区域中分配内存
>
> 2，Eden区域内存不足时发起一次minor gc，gc前判断此次gc是否安全，即年老代剩余空间是否大于新生代所有对象大小，不安全则判断是否允许担保失败，不允许则进行full gc
>
> 3，大对象直接进入年老代，存活时间长的对象进入年老代，若在survivor区域中相同年龄对象大于survivor空间的一半，则大于该年龄的所有对象进入年老代。

#### GC实现
1. Serial
2. ParNew

#### 类加载

###### 类加载器
1. Bootstrap ClassLoader 启动类加载器，C++实现
2. Extension ClassLoader 扩展类加载器
3. Application ClassLoader 应用类加载器，一般情况下程序中的默认加载器。
4. 用户自定义加载器，继承classLoader，重写fineClass方法，用于用户自定义加载类。


###### 加载过程
加载-> 验证 -> 准备 -> 解析 -> 初始化 ->使用 ->卸载

对象的创建
- 类加载的检查，未加载则先执行类加载过程
- 分配内存
- 初始化零值
- 设置对象头
- 执行init方法

###### 双亲委派模型

- 流程
> 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。

- 原则
1. 避免重复加载，父类已经加载过了，子类可以不用再次加载
2. 更加安全。如果不使用这种模型，用户可以自定义加载核心的api类，带来很多隐患。

- 自定义类加载使用场景
1. 隔离，在应用的不同模块中使用相同的jar包但是版本不一致的情况下，可以自定义类加载器进行隔离。一个类由两个不同的加载器加载的时候就不是同一个类。
2. 代码保护，对代码进行加密等


### JVM调优
######  目的
> 减少GC的频率和次数，过多的GC会占用更多的系统资源，影响系统性能

###### 频繁GC的原因
1. 新生代过小，大对象直接进入老年代
2. 老年代过小
3. 新生代过大，占用了过多的内存导致老年代过小

###### 参数设置
1. Xms memory start 堆初始大小
2. Xmm memory max 堆最大值
3. Xmn memory new 新生代大小
4. XX:NewRatio 新生代老年代比值
 
###### 命令/工具
1. jstat (statistics monitoring tool）jvm 监控，可以持续的监控JVM各个分区使用率及GC信息
2. jmap 内存映像工具，查看堆内信息
3. jstack 查看java进程内的堆栈信息
4. jps process status 查看java进程状态信息


