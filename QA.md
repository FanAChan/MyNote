1. volatile
 - 修饰变量，保证可见性，禁止指令重排序，不保证原子性
 - 在Java中对于volatile修饰的变量，编译器在生成字节码时，会在指令序列中插入内存屏障禁止处理器重排序。
 - 内存屏障是一组处理器指令，用于实现对内存操作的顺序限制
 - 内存屏障的作用：阻止屏障两侧的指令重排序；强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。
 -  在每个volatile写操作前插入StoreStore屏障（这个屏障前后的2个Store指令不能交换顺序），在写操作后插入StoreLoad屏障（这个屏障前后的2个Store Load指令不能交换顺序）；
    在每个volatile读操作前插入LoadLoad屏障（这个屏障前后的2个Load指令不能交换顺序），在读操作后插入LoadStore屏障（这个屏障前后的2个Load Store指令不能交换顺序）；
 - 由于CPU与内存的速度存在较大差异，引入了高速缓存提高提高速度。程序运行过程中，会从主存读取数据并缓存在高速缓存中，
  读写操作都先在高速缓存中进缓存再刷新回到主存。会产生了缓存一致性的问题。

2. JMM
 - Java内存模型，是Java虚拟机规范中定义的一种内存模型，屏蔽底层不同计算机的区别。
 - 现代计算机CPU的指令速度远超内存的读取速度，所以使用高速缓存来作为内存和处理器之间的缓冲。
 - 但也带来了新的问题：缓存一致性。CPU各自使用高速缓存但共享主存
 - JMM 描述了线程共享变量的访问规则，每一个线程都有一个工作内存，工作内存中保存了主存中变量的副本。
 线程对变量的所有操作都必须在工作内存中完成，而不能直接读主存中的变量，不同线程也不能直接访问对方工作内存中的变量，
 需要通过主内存进行传递。
 - MESI 缓存一致性协议。写数据时，如果发现操作的变量是共享变量，则发出信号通知其它CPU将该变量的缓存行设置为无效，其它CPU
 需要从内存重新读取。CPU通过嗅探在总线上传播的数据来检查缓存的值是够过期，过期则将缓存设置为无效状态，当处理器对这个数据
 进行修改操作时，会重新从系统内存中把数据读到处理器缓存中。
 
 3. synchronized 和lock的区别
    - synchronized是java内置锁，不需要手动的解锁，支持可重入，但是非公平，不可中断，条件单一。
    lock，基于AQS，拿reentrant为例，需要手动解锁，可重入，支持中断，支持多条件，支持超时操作。
    - synchronized优化，
    
 3. AQS
    - AQS主要是采用state，通过对state的CAS判断来获取锁和解锁，并且存在等待队列和条件等待队列来挂起相关线程并入队等待，
    有公平和非公平两者模式来唤醒等待的线程。
    
 4. 为什么需要AQS
    - 为了封装和抽象，通过封装了公共的方法，减少重复代码。
    
    
 5. 一致性hash
    - 一致性hash把hash的空间虚拟成一个圆环，key做hash落在圆环上，按顺时针查找，遇到的第一个缓存节点就命中。
    通过虚拟节点避免缓存分布不均，并且使得某个节点挂了之后，下面的节点只需要承担一部分的流量而不会因为
    需要承担所有流量而挂了，然后发生雪崩
 6. 过热key
    - 集群处理，备份热key，将一个key拆分到多个不同的节点上，防止单点过热。
    - 使用二级缓存，使用本地缓存来应对过热数据，例如hashmap，或者ehcache。
 7. 大key
    - 拆分成多个key，减轻单次操作的压力，限制单个key的大小
    - 大key的删除可以每次删除一部分，进行多次操作
    
    
 7. GC调优
    - GC调优一般具体是通过GC日志的情况来分析。
    - 如果发现minor gc频繁，新生代空间太小了。
    - 如果发现晋升的年龄很小，老年代迅速被填满，导致频繁的major gc，并且回收比率又很大，那说明
    对象的生命周期确实很短也需要调整新生代。
    - 如果看full gc很频繁，但是每次回收的内存就一点点，即大量内存无法回收，那目测就是内存泄露了。
    - 总体上就是根据分代的根本，也就是新生代朝生夕死的事实调整GC，避免分配大对象。具体还是得分析GC日志。
    
    
    
JVM？
GC？    
synchronized原理？
锁优化？ 锁消除，自旋，偏向锁，轻量级锁，重量级锁？
Lock?
AQS?
    

MYSQL 索引？
数据库缓存一致性问题？
事务？
隔离级别？
锁？间隙锁？
MVCC?
redolog undolog binlog?
XA事务？


MQ?
消息的可靠性，重复消费，幂等性？
顺序性？   
    
   
    
redis为什么单线程？
IO多路复用？
redis五个对象？
每个对象的底层数据结构？
redis的过期删除机制？
淘汰机制？
redis的RDB和AOF？
redis的事务？
redis的主从?
哨兵？
集群？
redis的分布式锁？
redlock？
redis的一些优化？
大key拆分？
缓存击穿，雪崩，穿透，热key?
redis分布式锁？


zk分布式锁?

spring AOP？
IOC?

分布式事务？
