AQS 是一个用来构建锁和同步器的框架
作用
1，管理同步状态
2，管理同步队列
3，阻塞和唤醒线程

AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制

获取锁的伪代码
while (不满足获取锁的条件) {
    把当前线程包装成节点插入同步队列
    if (需要阻塞当前线程)
        阻塞当前线程直至被唤醒
}
将当前线程从同步队列中移除

释放锁的伪代码
修改同步状态
if (修改后的状态允许其他线程获取到锁)
    唤醒后继线程


两种资源共享方式
1独占 私有 如reentrantlock 公平锁 非公平锁
公平锁：根据先后顺序
非公平锁：抢，在lock只有调用cas抢锁，未抢到则调用 tryAcquire ，若发现未被锁则再次调用cas抢锁，失败则等待，公平锁在tryAcqurie则会判断是否存在线程在等待，是则等待前置线程。
非公平锁性能跟好，但是可能会出现线程长期等待的情况。
2 共享锁
semaphore 信号量 标记资源可共享次数
countDownLatch 倒计时器 阻塞线程直至计时器为0 场景：等待多个线程加载环境或领多个线程同时在赛跑起点 一次性的
CyclicBarrier 栅栏 多次使用，基于 ReentrantLock(ReentrantLock也属于AQS同步器)和 Condition 的，类似countDownLatch