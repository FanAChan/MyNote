## BlockingQueue
> 一种阻塞队列
> 队列为空时，获取元素阻塞
> 队列满时，新增元素阻塞

调用方法无法满足时有四种形式：
1. 抛出异常
2. 返回特殊值，null或者false
3. 阻塞等待直到满足条件
4. 阻塞等待一段时间

不支持null值，null值作为调用失败的特殊值返回，添加null抛出NPE


##### 实现

###### ArrayBlockingQueue
1. 底层使用数组实现
2. 初始化时指定大小，初始化后不允许改变
3. 支持公平和非公平锁
4. 使用ReentrantLock保证线程安全
5. 保存头节点下标及尾结点下标，take或add时不对数组元素进行移动，只修改下标
6. remove时如果是首个元素，只修改下标，如果是其它元素，往一段移动，修改尾节点位置

###### LinkedBlockingQueue
1. 底层使用链表实现
2. 初始化时可以指定大小，也可以不指定，不指定最大容量为Integer.MAX_VALUE
3. 读写锁分离，使用原子类进行计数
4. 吞吐量跟高，但是并发高情况下性能不可控，线程切换损耗资源
5. 在put时会在元素入队后还有剩余空间时调用notFull.signal();方法唤醒阻塞在notFull上的线程，
原因是notFull条件属于putLock，而takeLock要调用notFull必须先获取putLock，所以在put方法上调用
notFull.signal();可以减少不必要的阻塞等待时间，提高并发效率，take方法也同样如此。只有刚好为空或者队列满的
时候，才会由相对的方法进行唤醒操作，如队列空时，有put方法获取takeLock并进行notEmpty.signal();唤醒等待线程，
因为当前所有的take线程都被阻塞，只能等待put线程唤醒。

###### PriorityBlockingQueue
1. 底层使用数组实现，实际为堆的形式

###### DelayQueue
1. 底层使用优先级队列实现
2. 元素必须是Delayed的子类
3. 队列的头节点的延迟时间大于0时，元素获取线程阻塞，并且会将首个等待的线程引用暂存为leader，等待头结点的延迟时间后唤醒，获取元素。
等待期间如果有新的元素进入队列并且位于头节点，则将leader置空。最后再队列不为空时唤醒等待在条件上的线程。