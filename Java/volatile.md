
修饰变量，保证可见性，禁止指令重排序，不保证原子性
可见性
> 保证取到的是最新的值，但不会更新且无法更新已经获取的值。
> 当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为
> 无效状态并且锁住缓存行，因此当其他CPU需要读取这个变量时，要等锁释放，并发现自己缓存行是无效的，那么它就会从内存重新读取。  

有序性：对Volatile变量进行读写操作时，其前面的操作必须已经完成且当前操作对后面可见
不保证原子性：无法同步改变已经读取到工作内存中的值
禁止指令重排序：以操作Volatile变量的代码为界限，禁止操作代码前后的代码一起进行重排序


###### 实现原理
volatile 关键字修饰的变量会存在一个lock的前缀
lock前缀完成类似内存屏障的功能
Lock会对CPU总线和高速缓存加锁，可以理解为CPU指令级的一种锁
具体执行是先对总线和缓存加锁，然后再执行后面的命令。在Lock锁足总线的时候，其它CPU的读写请求都会被阻塞，
直到锁释放，最后把缓存中的脏数据全部刷新回主内存，且使其它CPU的该缓存失效，再释放锁


volatile i = 0;
i++；为啥不保证线程安全？

i++不是一个原子操作，包含了三步
在读的时候一定是最新的值，而一个线程完成自增并写回内存中时，存在另一个线程也已经完成了自增的操作，该线程
并不需要再次读取数据，可以直接回写，导致线程不安全



 使用volatile变量时必须从主存中获取最新的变量值，使用完只有必须保证立刻将值同步回主存中
 使用场景：1，不依赖旧值2，没有包含在具有其他变量的不变式中
 
 
  内存屏障是CPU指令。如果你的字段是volatile，Java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。
 
 下面是基于保守策略的JMM内存屏障插入策略：
 
 在每个volatile写操作的前面插入一个StoreStore屏障。
 
 在每个volatile写操作的后面插入一个StoreLoad屏障。
 
 在每个volatile读操作的前面插入一个LoadLoad屏障。
 
 在每个volatile读操作的后面插入一个LoadStore屏障。
 
 内存屏障，又称内存栅栏，是一组处理器指令，用于实现对内存操作的顺序限制。 
 
 内存屏障可以被分为以下几种类型
 LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。
 StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。
 LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。
 StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。        
 在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。
 
 
 为什么会有内存屏障
 每个CPU都会有自己的缓存（有的甚至L1,L2,L3），缓存的目的就是为了提高性能，避免每次都要向内存取。但是这样的弊端也很明显：
 不能实时的和内存发生信息交换，分在不同CPU执行的不同线程对同一个变量的缓存值不同。
 用volatile关键字修饰变量可以解决上述问题，那么volatile是如何做到这一点的呢？那就是内存屏障，内存屏障是硬件层的概念，
 不同的硬件平台实现内存屏障的手段并不是一样，java通过屏蔽这些差异，统一由jvm来生成内存屏障的指令。Lock是软件指令。
 
 内存屏障是什么
 硬件层的内存屏障分为两种：Load Barrier 和 Store Barrier即读屏障和写屏障。
 内存屏障有两个作用：
 阻止屏障两侧的指令重排序；
 强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。
 对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载新数据；
 对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。
 
 
 volatile语义中的内存屏障
 volatile的内存屏障策略非常严格保守，非常悲观且毫无安全感的心态：
 在每个volatile写操作前插入StoreStore屏障（这个屏障前后的2个Store指令不能交换顺序），在写操作后插入StoreLoad屏障（这个屏障前后的2个Store Load指令不能交换顺序）；
 在每个volatile读操作前插入LoadLoad屏障（这个屏障前后的2个Load指令不能交换顺序），在读操作后插入LoadStore屏障（这个屏障前后的2个Load Store指令不能交换顺序）；
 
 由于内存屏障的作用，避免了volatile变量和其它指令重排序、线程之间实现了通信，使得volatile表现出了锁的特性。
 在Java中对于volatile修饰的变量，编译器在生成字节码时，会在指令序列中插入内存屏障禁止处理器重排序。