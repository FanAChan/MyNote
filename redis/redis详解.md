## redis详解
#### 作用
1. 缓存
2. 分布式锁
3. 消息队列
##### redis的优点

#### 基础操作

```
1，string，
  get key   
  set key value   
  mget key1 [key2]...获取多个key的值
  mset key1 value1 [key2 value2]...设置多个key的值
  setnx key value 当key不存在是设置值
  incr key 将value加1
  incrby key increment 将value增加increment
  decr key 减1
  decr key decrement 减decrement
  append key value 对存在的key添加value到其末尾
2，hash，string类型的field和value的映射表，hash特别适合用于存储对象
  hset key field value 
  hmset key field1 value1 [field2 value2].....设置哈希表key中的属性（同时将多field-value (域-值)对设置到哈希表 key 中。）
  设置哈希表key中字段field值
  hsetnx key field value   哈希表key中字段field不存在时设置值
  hmget key field1 [field2]......获取哈希表key中多个field的值
  hget key field     获取哈希表中单个值
  hmgetall key    获取哈希表中所有的字段和值
  hvals key    获取哈希表中所有的值
3，set，
    sadd key value
    scard key 计数
    sdiff key1 [key2] 集合1与集合2的差异
    sismember key value
    smembers key
    spop key 随机返回
    srem key value
4，sorted set，
    zadd key score value
    zscore key value 获取指定成员的分数
    zincrby key increment value 给指定成员添加增量
    zrange key start end 返回下标start与end之间的所有成员
    zrangebyscore key start end
    返回指定分数区间的成员列表
    
5，list    顺序列表，可以从左（头）部或者右（尾）部进行操作
    lpush key value1 [value2]
    rpush key value1 [value2]
    lindex key index
    llen key
    lpop
    rpop
    lrange start stop
    lset key index value
```

数据两大通用规则
create if not exits 不存在是创建
drop if empty 最后一个值被移除时删除key
 
### 速度快的原因
```
1. 内存读写
2. 单线程操作，减少了线程之间切换的消耗
3. 采用了非阻塞I/O多路复用机制（单线程跟踪多个I/O流状态进行管理）
4. 数据类型简单
```
### 问题

##### 使用redis主要会遇到的问题（缺点）
1. 缓存穿透
    
```
故意请求不在缓存中的数据，所有的请求都直接进入数据库，导致数据库连接异常
```

```
解决方法：
    1，互斥锁，少量线程请求数据库并重建缓存
    2，异步更新策略
    3，提供判断请求是否有效的拦截机制。布隆过滤器，将可能存在的数据放入一个足够大的bitmap中拦截数据库中一定不存在的数据缓存空数据，设置较短的过期时间
```

2. 缓存雪崩
    
```
同一时间大量key失效，大量请求进入数据库
```
```
解决方法：
    1，给缓存添加随机失效时间，避免同一时间大量失效
    2，互斥锁，少量线程请求数据库并重建缓存
    3，双缓存
```

3. 缓存数据库读写一致性
> 缓存读写模式/更新策略
>1.  Read/Write Through Pattern  （读写穿透）把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 DB
读缓存，不存在读数据库并写入缓存
写缓存，缓存负责同步更新数据库
>2. Cache Aside Pattern（旁路缓存模式）
读缓存，不存在读数据库并写入缓存
写数据库，删除缓存，懒汉模式，保证在使用的时候才进行更新。避免多次更新的多次修改缓存，且缓存数据可能涉及多个表的数据整合，在涉及每个表的时候都更新缓存影响较大，而删除缓存后只在使用缓存的时候再进行加载开销更低
    ==问题==：请求1删除完缓存在修改数据库之前，请求2发起读请求直接读数据库读出旧数据并放入缓存，此时请求1修改数据库，产生不一致
>3. Write Behind Pattern（异步缓存写入） 为异步批量的方式来更新 DB，适合一些数据经常变化的业务场景比如说一篇文章的点赞数量、阅读数量


4. 缓存的并发竞争问题
    
```
解决办法：
    1，分布式锁（不要求顺序）
    2，添加时间戳，若当前时间戳早于已设置的，则放弃操作，保留原值
    3，队列
```

5. 缓存击穿：超热数据在缓存过期后超高的并发导致请求直接落入DB
    
```
1. 互斥锁
2. 定时线程主动设置更新缓存
3. 设置永不过期
```


6. 缓存预热：提前将部分热数据放入缓存中

7. 缓存降级


#### 过期策略和内存淘汰机制
##### redis采用的是定期删除+惰性删除策略
###### 定期删除：每隔一定时间随机抽查部分key是否过期，删除其中过期的key
###### 惰性删除：在获取的时候判断key是否过期，过期则删除
###### 过期数据长时间未被抽查和获取，则会滞留在内存中，根据配置的内存淘汰策略
1. noeviction 内存不足以写入则报错
2. allkeys-lru 删除最近最少使用
3. allkeys-random 随机删除
4. volatile-lru 在设置了过期时间的key中删除最近最少使用
5. volatile-random 在设置了过期时间的key中随机删除
6. volatile-ttl 在设置了过期时间的key中，有更早过期的key优先删除
##### 不使用定时删除策略的原因：使用定时删除策略需要一个定时器对CPU资源消耗较大）



#### 持久化
> 数据全部都在内存中，若宕机，则全部数据丢失。持久化可保障数据不丢失。

##### 持久化方式
- RDB 快照
> 快照，是一次全量备份。是内存数据的二进制序列化形式，存储紧凑，文件较小。
> 
> 实现方式：使用多进程COW(==copy on write==)。父进程fork一个子进程负责进行快照持久化。子进程对数据进行持久化不会对现有的内存数据进行修改，父进程还在持续接收客户端请求不断对内存进行修改。父进程在对数据进行修改时，将数据所在的共享页面复制一份，然后在复制的页面进行修改，不影响子进程的快照工作。
>
> 不会超过原有数据内存的2倍大小，且redis实例中往往冷数据的占比比较高。所以很少出现所有页面都被分离的情况。

- AOF 日志，append on file
> 连续的增量备份。记录的是内存数据修改的指令记录文本，长期运行会非常大，重启redis服务时对指令进行重放，时间比较长，可以定期给AOF文件进行重写瘦身。
>
> 命令处理完成后写入AOF。实际是先写入内存缓存，然后异步写入AOF，如果写入缓存未写入文件时系统宕机则会出现日志丢失。使用fsyn函数可强制刷入磁盘，但因为是磁盘IO操作，性能很差。所以一般是隔一段时间执行一次，如1s，在数据安全性和性能之间做一个折中，保持高性能的同时减少数据丢失。还有一种策略是永不调用，由系统决定何时调用，不安全。
>
> bgrewwriteaof 进行瘦身。即开辟一个子进程对内存进行遍历，转换成一系列操作指令，重新写入一个新的AOF文件中。序列化完毕后再将操作期间发生的增量AOF日志追加到新的AOF日志文件中并替代旧的AOF。

- 混合持久化
> 4.0 提供了混合持久化的选项。将RDB和AOF的文件存在一起。aof是从持久化开始到持久化结束这段时间内的增量日志。重启效率得到提升，且减少了数据丢失。
备份
> 因为RDB的子进程及AOF的fsyc操作都对系统性能有较大的影响，所以一般不在主节点进行持久化操作，主要在从节点进行，没有客户端的请求的压力，一般资源比较充足。
>
> 出现网络分区情况时，会出现主从节点数据不一致的情况。出现网络分区时主节点挂了，就会导致数据丢失，可以增加一个从节点减小网络分区的概率，以及做好实时监控，保证网络及快速恢复。


#### 事务

1. multi 开始
2. exec 执行提交
3. discard 丢弃，丢弃缓存队列中所有的指令

> multi之后的命令缓存在服务器的一个事务队列中，收到exec命令后开始执行整个事务队列。遇到指令执行失败时，后面的指令还会继续执行，所以不具备原子性。


###### watch命令
> 类似于MVCC。watch盯住关键变量，当事务执行时，判断自watch后是否修改，若是则在执行exec命令时返回NULL代表执行失败。禁止在mutli和exec之间执行


#### 集群

##### redis集群方式

- Codis
> 代理中间件，Codis接收客户端的指令，负责将指令转发到对应的Redis实例，再将返回结果转发给客户端。
>
> 默认将所有的key划分为1024个slot槽位，每个key对应一个槽位，一个槽位映射一个redis实例，Codis在内存中维护槽位与实例的映射关系，还使用zookeeper持久化槽位关系。提供了dashboard观察和修改槽位关系，当槽位关系发生变化时，Codis Proxy会监听到变化并重新同步槽位关系。
>
>扩容时，需要将制定槽位下的所有key进行迁移，迁移过程中接收到当前槽位的key的命令时，强制同步当前key然后使用将请求转发到新的redis实例。
>
> 提供了自动均衡功能。当空闲时，自动迁移。
>
> 问题：1，不支持事务，因为事务中的key不在一个redis实例中。2，rename操作问题 ,存在一系列不支持的命令。3 大key迁移问题


- Cluster
> 去中心化，每个节点负责整个集群的一部分数据，负责的数据量可能不一样，多个节点相互连接组成一个对等的集群，通过一种特殊的二进制协议交互集群信息。

##### sentinel 哨兵
1. 集群监控 监控节点是否正常工作
2. 消息通知 如果节点发送故障进行消息通知
3. 故障转移 如果master节点挂了，则自动转移到从节点
4. 配置中心 发生故障转移通知客户端新的master节点

> 也是一个集群，可以当做为zookeeper集群。
> 负责监控主从节点的状态，当主节点挂掉时，选择一个最优的从节点作为新的主节点并重新建立主从关系。客户端连接集群时，先连接sentinel询问主节点的地址，再连接主节点进行数据交互。

> redis是异步同步，保证AP，保证最终一致性，从节点会努力追赶主节点，与主节点保持一致

- 主从同步 
- 从从同步 减轻主节点负担
- 增量同步
> 同步的是指令流，主节点将对数据产生修改性影响的指令记录在本地内存缓存中，然后异步同步到从节点，从节点执行指令。主节点缓存buffer使用环形数组，如果从节点短时间内无法和主节点进行同步，导致指令积压，后续的指令会覆盖一部分未同步的指令。
- 快照同步
> 非常的消耗资源
> 首先在主节点进行gbsave将内存数据全部快照存储到磁盘，然后将快照文件传送到从节点，从节点进行全量加载，加载前需要将从节点全部数据清空，执行完成后继续增量同步。若快照同步时间过长，也会导致增量指令被覆盖的情况，然后就再次发起快照同步，陷入死循环。

- 无盘复制
> 主节点直接通过套接字将快照发送到从节点，主节点一边遍历内存，一边将序列化的内容发送到从节点，从节点先保存到磁盘，再进行一次性加载。

###### wait指令
> redis同步是异步复制，wait指令可以让异步复制变成同步复制，确保系统的强一致性。
>
> 提供两个参数从节点数量n和时间t毫秒，即等待wait指令前的所有写操作同步到n个从节点，最多等待nh毫秒，n=0则无限等待。