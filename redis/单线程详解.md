
前提
> 操作系统会为每一个TCP连接在内核空间中维护一个输入缓冲区和输出缓冲区，网络传输的数据会先被写入连接的
>输入缓冲区，这个过程是由操作系统自己完成的，无需应用程序参与。应用程序在处理自身逻辑的时候，操作系统
>也可以对网络上传输的数据进行接收并写入输入缓冲区的。对于读取网络数据而言，IO复用的作用实际上是监听
>一系列网络连接对应的输入缓冲区中书否有数据，如果有，则触发读事件，并通知应用程序。应用程序调用read系统
>调用的本质是从内核空间的输入缓冲区之中将数据读取到用户空间的内存中，因为应用程序是无法直接操作内核空间
>中的数据的。

##### IO多路复用的实现
> redis包装了常见的select、epoll、evpor和kqueue这些常见的IO多路复用函数库，为每个包装对象实现了
>相同的API，所以redis的底层实现是可以互换的。redis会根据系统支持的IO复用选择性能最高的作为底层实现。
``` 
- ae.c
/* Include the best multiplexing layer supported by this system.
 * The following should be ordered by performances, descending. */
#ifdef HAVE_EVPORT
#include "ae_evport.c"
#else
    #ifdef HAVE_EPOLL
    #include "ae_epoll.c"
    #else
        #ifdef HAVE_KQUEUE
        #include "ae_kqueue.c"
        #else
        #include "ae_select.c"
        #endif
    #endif
#endif
```


单线程
- 单线程是指处理请求命令的线程只有一个，但是还是存在其他辅助线程，例如aof日志线程

> 对于不同的IO多路复用函数的获取连接上就绪事件的方法，redis统一使用aeApiPoll进行了封装。
> 主线程在aeProcessEvents函数(文件事件分派器)中，通过调用aeApiPoll阻塞的等待连接上的就绪事件。
>（即本质上没有一个额外的就绪事件队列，而是通过IO复用程序获取所有的就绪事件）
> 主线程遍历从aeApiPoll中返回的就绪事件列表依次处理连接上产生的事件。
> 如果连接上是可读事件，则调用readQueryFromClient函数，readQueryFromClient函数调用系统函数(文件事件处理)
> read将内核缓冲区中点数据读取到用户空间的缓冲区，并将数据尝试解析成命令数据。
> 主线程执行完所有的文件事件后，会对时间事件进行处理，然后按照这种顺序循环处理。


多线程
> 单线程版本下，IO复用，就绪事件分发，网络数据的读取，数据的解析执行，以及网络数据输出都是由主线程执行的。
> redis的性能瓶颈在IO处理，使用多线程并发处理IO提高IO效率，减少IO等待时间，除IO处理外的其它功能还是由主线程完成。
> 多线程版本中主线程获取了连接上的所有就绪事件后，遍历就绪事件，负责将事件分发给子线程进行
> 实际的IO操作，子线程完成IO操作后，由主线程完成命令的执行

```
- 读事件修改 readQueryFromClient
    - 如果开启了多线程模型，且未标记可读事件，则将socket加入读事件等待队列
    - IO Main线程和子线程都会调用当前方法，根据标识进行判断具体执行逻辑
    - 未标记为可读事件的则将可读事件插入可读事件队列，已标记的则处理实际的可读事件
    - 实际处理读事件，将数据从socket中读出放入缓冲区，数据完整后将连接标记为Pending-Command
```


